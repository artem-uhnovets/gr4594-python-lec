# Лекция №1

## [Оглавление](#оглавление)
* [Немного истории](#немного-истории)
* [Виртуальное окружение](#виртуальное-окружение)
* [Синтаксис Python](#синтаксис-python)
* [Операторы и выражения](#операторы-и-выражения)
* [Оператор вывода данных](#оператор-вывода-данных)
* [Базовые типы данных Python:](#базовые-типы-данных-python)
* [Объявление переменной](#объявление-переменной)
* [Какой тип данных содержится в переменной](#какой-тип-данных-содержится-в-переменной)
* [Как сделать комментарий?](#как-сделать-комментарий)
* [Интерполяция](#интерполяция)
* [Оператор ввода данных](#оператор-ввода-данных)
* [Арифметические операции](#арифметические-операции)
* [Приоритет арифметических операций](#приоритет-арифметических-операций)
* [Округление числа](#округление-числа)
* [Сокращенные операции присваивания](#сокращенные-операции-присваивания)
* [Логические операции](#логические-операции)
* [Операторы тождественности is, is not](#операторы-тождественности-is-is-not)
* [Операторы членства(принадлежности in, not in)](#операторы-членствапринадлежности-in-not-in)
* [Управляющие конструкции: if, if-else](#управляющие-конструкции-if-if-else)
* [Сложные условия](#сложные-условия)
* [Управляющие конструкции: while и вариация while-else](#управляющие-конструкции-while-и-вариация-while-else)
* [Цикл for](#цикл-for)
* [Цикл range](#цикл-range)
* [Команды для работы со строками](#команды-для-работы-со-строками)
* [Срезы](#срезы)

#### [Немного истории](#немного-истории)
В декабре 1989 года голландец Гвидо (Guido van Rossum) —
будущий создатель одного из самых популярных языков
программирования — искал хобби-проект, которому можно было
бы посвятить рождественские каникулы.

Первая «официальная» версия языка увидела свет в 1994 году.

#### [Виртуальное окружение](#виртуальное-окружение)
Допустим у нас есть два проекта: "Project A" и "Project B". Оба проекта зависят от библиотеки Simplejson. Проблема возникает, когда для "Project A" нужна версия Simplejson 3.0.0, а для проекта "Project B" — 3.17.0. Python не может различить версии в глобальном каталоге site-packages — в нем останется только та версия пакета, которая была установлена последней. Решение данной проблемы — создание виртуального окружения (virtual environment).
* Создать новый проект в пустой папке (рабочего пространства).
* В терминале прописать python3 -m venv .folder (.folder — название папки, в которой будет работа).
* Выбираем `Yes` для работы с новым виртуальным окружением.
* Справа внизу у Вас должно появиться виртуальное окружение,
которое мы установили

#### [Синтаксис Python](#синтаксис-python)
Синтаксис Python
Синтаксис Python очень простой и примитивный.
Пример с языком C#.
```c#
Console.WriteLine(1);
int n = 1;
int n = Convert.ToInt32(Console.ReadLine()); 
```
```Python
print(1)
n = 1
n = int(input())
```
#### [Операторы и выражения](#операторы-и-выражения)
Большинство строк программного кода представляют собой выражения.
Например:
```
1 + 2
```
 — это выражение, состоит из 2 частей:
* оператор `+` это функционал
* операнды `1` и `2` это данные, над которыми производятся действия
#### [Оператор вывода данных](#оператор-вывода-данных)
##### [Оглавление № 1](#лекция-№1)
функция, которая выводит данные на экран
```Python
print(var1, var2, var3)
# var1, var2, var3 - переменные или значения.
```

#### [Базовые типы данных Python:](#базовые-типы-данных-python)
* `int` целые числа
* `float` дробные числа
* `bool` логический тип данных (True/False)
* `str` строка

#### [Объявление переменной](#объявление-переменной)
название переменной = значение переменной

(один знак равенства обозначает присвоение значения к переменной)

```Python
a = 123
b = 1.23
print(a) # 123
print(b) # 1.23
```
Python поддерживает и `множественное` присваивание.
```Python
a, b, c = 1, "python", [1,2,3]
print(a, b, c)  # 1 python [1, 2, 3]
```
С помощью такого присваивания можно поменять значения переменных между собой:
```Python
a = 1
b = 2
a, b = b, a
print(a, b) # 2 1
```
Также с помощью множественного присваивания можно "распаковывать" строки `str`, списки `list`, кортежи `tuple` и словари `dict`.

**НЕЛЬЗЯ** указать переменную, не присвоив ей какое-либо значение. 

**НО** можно присвоить значение `None` и использовать переменную дальше по коду.
```Python
value = None
a = 123
b = 1.23
print(a)     # 123
print(b)     # 1.23
value = 1234
print(value) # 1234
```
Чтобы создать строку и сохранить ее в переменную используют одинарные `' '` или двойные `" "` кавычки.
```Python
s = 'hello,' # создание 1-ой строки
w = "world"  # создание 2-ой строки
print(s, w)
```
#### [Какой тип данных содержится в переменной](#какой-тип-данных-содержится-в-переменной)
##### [Оглавление № 1](#лекция-№1)
Когда мы хотим узнать тип данных у переменной необходимо применить функции `type(varName)`.
```Python
print(type(name)) # функция, которая указывает на тип данных
```
#### [Как сделать комментарий?](#как-сделать-комментарий)
Если Вы хотите закомментировать строку 
* применить специальный символ `#`
* если Вам нужно закомментировать сразу несколько строк выделите их
и нажмите `ctrl + /`
* или же используйте тройные кавычки `'''` с двух сторон.
```Python
# print(1)
# —------------------
'''print(1)
print(1)
print(1)
print(1)'''
print(1)
```
Можно ли писать кавычки в виде текста внутри строки?

Пример:
```
my mom shouted: "good luck!".
```
Используйте разные кавычки для объявления переменной и внутри строки или спец комбинацию `\"`.
```Python
s = 'hello "world"'
print(s) # hello "world"
s = "hello 'world'"
print(s) # hello 'world'
s = 'hello \"world\"'
print(s) # hello "world"
```
#### [Интерполяция](#интерполяция)
##### [Оглавление № 1](#лекция-№1)
Способ получить сложную строку из нескольких простых с использованием специальных шаблонов.
```Python
a = 3
b = 11
s = 2022
print(a, b, s)                                 # 3 11 2022
print(a, '-', b, '-', s)                       # 3 - 11 - 2022
print('{} - {} - {}'.format(a, b, s))          # 3 - 11 - 2022
print(f'first - {a} second - {b} third - {s}') # first - 3 second - 11 third - 2022
```
#### [Оператор ввода данных](#оператор-ввода-данных)
Используется следующая функция
```Python
input()
```
**НО** по умолчанию c помощью функции `input()` вводится строка
```Python
print('Введите 1ое число: ')
a = input()
print('Введите 2ое число: ')
b = input()
print(a, '+', b, '=', a + b)
print(type(a))
print(type(b))

# Введите 1ое число: 
# 10
# Введите 2ое число: 
# 20
# 10 + 20 = 1020
# <class 'str'>
# <class 'str'>
```
Необходимо воспользоваться вспомогательными функциями, которые позволят вводить числа и
работать с ними **(иногда все-таки нельзя перевести один тип данных в другой.)**.

* `int()` - функция, которая позволяет перевести из любого типа данных в число
    ```Python
    n = 1.345
    print(int(n))
    m = '345'
    print(m * 2)
    print(int(m) * 2)
    # 1 Отбрасывается дробная часть вне зависимости больше 0.5 или меньше
    # 345345 При умножении строки на число, она повторяется столько раз на какое была умножена
    # 690
    ```
* `float()` - функция, которая позволяет перевести из любого типа данных в вещественный
    ```Python
    n = '1.345'
    print(float(n) * 2)
    m = 2
    print(float(m))
    # 2.69
    # 2.0
    ```
* `str()` - функция, которая позволяет перевести из любого типа данных в строку
    ```Python
    n = 1.345
    print(str(n) * 2)
    # 1.3451.345
    ```
* пример когда `нельзя` перевести один тип данных в другой
    ```Python
    n = '123Hello'
    print(int(n))
    print(float(n))
    # ValueError: invalid literal for int() with base 10: '123Hello'
    # Это ошибка типа данных. Невозможно сделать число из строки.
    ```
Как все-таки ввести число в Python?
```Python
print('Введите число: ')
n = int(input())
print(n * 2)
print(type(n))
# Введите число: 
# 5
# 10
# <class 'int'>
```
```Python
n = int(input('Введите число: '))
print(n * 2)
print(type(n))
# Введите число: 5
# 10
# <class 'int'>
```
```Python
n = input('Введите число: ')
print(int(n) * 2)
print(type(n))
# Введите число: 10
# 20
# <class 'str'>
```
#### [Арифметические операции](#арифметические-операции)
##### [Оглавление № 1](#лекция-№1)
Cинтаксис у базовых арифметический операций
* `+` cложение
* `-` вычитание
* `*` умножение
* `/` деление (по умолчанию в вещественных числах)
* `%` остаток от деления
* `//` целочисленное деление
* `**` возведение в степень

#### [Приоритет арифметических операций](#приоритет-арифметических-операций)
1. `**` возведение в степень
2. `*` умножение
3. `/` деление
4. `//` целочисленное деление
5. `%` остаток от деления
6. `+` cложение
7. `-` вычитание

**`В Python нет лимита по хранению данных (нет ограничения по битам для
хранения числа из-за динамической типизации данных)`**

#### [Округление числа](#округление-числа)
Используется следующая функция
```Python
round()
```
Можно указать количество знаков после запятой
```Python
a = 1.43425
b = 2.2983
c = round(a * b, 5)
print(c) # 3.29634
```
#### [Сокращенные операции присваивания](#сокращенные-операции-присваивания)
```Python
iter = 2
iter += 3  # iter = iter + 3
iter -= 4  # iter = iter - 4
iter *= 5  # iter = iter * 5
iter /= 5  # iter = iter / 5
iter //= 5 # iter = iter // 5
iter %= 5  # iter = iter % 5
iter **= 5 # iter = iter ** 5
```
#### [Логические операции](#логические-операции)
##### [Оглавление № 1](#лекция-№1)
* `>` больше
* `>=` больше или равно
* `<` меньше
* `<=` меньше или равно
* `==` равно (проверяет, равны ли числа)
* `!=` не равно (проверяет, не равны ли значения)
* `not` не (отрицание)
* `and` и (конъюнкция)
* `or` или (дизъюнкция)

Результатом будет либо `True` либо `False`
```Python
a = 1 > 4
print(a)            # False
a = 1 < 4 and 5 > 2
print(a)            # True
a = 1 == 2
print(a)            # False
a = 1 != 2
print(a)            # True

# можно сравнивать не только числовые значения, но и строки:
a = 'qwe'
b = 'qwe'
print(a == b)       # True

# можно использовать тройные и даже четверные неравенства:
a = 1 < 3 < 9 < 10
print (a)           # True
```

Так же есть:
* `is`
* `is not`
* `in`
* `not in`

#### [Операторы тождественности is, is not](#операторы-тождественности-is-is-not)
##### [Оглавление № 1](#лекция-№1)
Операторы сравнивают размещение двух объектов в памяти
* `is` возвращает `True` если оба операнда указывают на один и тот же объект
* `is not` возвращает `True` если оба операнда указывают на разные объекты
```Python
x = 5
print(type(x) is int)  # True

x = 5.1
print (type(x) is int) # False

x = [1, 2, 3]          # id(x) = 64620552
y = [1, 2, 3]          # id(y) = 60529960
print(x is y)          # False

x = 1
y = 1
print(x is y)          # True

x = 1
y = 2
print(x is y)          # False

x = 1
y = 1
print(x is not y)      # False

x = 1
y = 2
print(x is not y)      # True
```
#### [Операторы членства(принадлежности in, not in)](#операторы-членствапринадлежности-in-not-in)
##### [Оглавление № 1](#лекция-№1)
Предназначены они для проверки наличия элемента в строке `str`, списке `list`, словаре `dict` или кортеже `tuple`.
* `in` возвращает `True` если элемент присутствует в последовательности
* `not in` возвращает `True` если элемент отсутствует в последовательности
```Python
print("host" in "host=local")           # True
print(2 in [1,2,4,5])                   # True
print("one" in {"one": 1, "two": 1})    # True в словаре проверка по ключам
print(True in ("string", 2, True))      # True
print("str" not in ("string", 2, True)) # True
```

#### [Управляющие конструкции: if, if-else](#управляющие-конструкции-if-if-else)
`Отступы` в Python играют огромную роль, стоит поставить на 1 пробел меньше, чем нужно, Ваша программа будет не рабочая.

`Отступом` отделяется блок кода, который находится внутри операторов ветвления, циклов, функций и тд. Обычно внутри VSC отступы ставятся автоматически, но необходимо знать чему равны отступы:
* Кнопка `TAB`
* `4` пробела
```Python
if condition:
    # operator 1
    # operator 2
    # ...
    # operator n
else:
    # operator n + 1
    # operator n + 2
    # ...
    # operator n + m
```
```Python
a = int(input("a= "))
b = int(input("b= "))
if a > b:
    print(a)
else:
    print(b)
```
Ещё один вариант использования операторов `else-if` → в связке с `elif (else if)`.

Проверяем первое условие, если оно не выполняется, проверяем второе и так далее.

Как только будет найдено верное условие, все остальные будут игнорироваться.
```Python
if condition1:
    # operator
elif condition2:
    # operator
elif condition3:
    # operator
else:
    # operator
```
```Python
username = input('Введите имя: ')
if username == 'Маша':
    print('Ура, это же МАША!')
elif username == 'Марина':
    print('Я так ждала Вас, Марина!')
elif username == 'Ильнар':
    print('Ильнар - топ)')
else:
    print('Привет, ', username)
```

#### [Сложные условия](#сложные-условия)
##### [Оглавление № 1](#лекция-№1)
Сложные условия создаются с помощью логических операторов, таких как: `and`, `or`, `not`.
```Python
if condition1 and condition2: # выполнится, когда оба условия окажутся верными
    # operator
if condition3 or condition4: # выполнится, когда хотя бы одно из условий окажется верным
    # operator
```
```Python
n = int(input())
if n % 2 == 0 and n % 3 == 0:
    print('Число кратно 6')
if n % 5 == 0 and n % 3 == 0:
    print('Число кратно 15')
```
#### [Управляющие конструкции: while и вариация while-else](#управляющие-конструкции-while-и-вариация-while-else)
Цикл позволяет выполнить блок кода, пока условие является верным.
```Python
while condition:
    # operator 1
    # operator 2
    # ...
    # operator n
```
```Python
n = 423
summa = 0
while n > 0:
    x = n % 10
    summa += x
    n = n // 10
print(summa) # 9
```
**`while-else`**
```Python
while condition:
    # operator 1
    # operator 2
    # ...
    # operator n
else:
    # operator n + 1
    # operator n + 2
    # ...
    # operator n + m
```
Блок `else` выполняется, когда основное тело цикла перестает работать **САМОСТОЯТЕЛЬНО**!

Если вспомнить `C#`, то конструкция `break` может прекратить работу цикла. Внутри Python она также существует и используется точно также.
```Python
i = 0
while i < 5:
    if i == 3:
        break
    i = i + 1
else:
    print('Пожалуй')
    print('хватит )')
print(i)  # 3
# то что находится внутри else будет игнорироваться, так как цикл завершился не самостоятельно.
```
Пример программного кода **без** использования `break`
```Python
n = 423
summa = 0
while n > 0:
    x = n % 10
    summa += x
    n = n // 10
else:
    print('Пожалуй')
    print('хватит )')
print(summa)
# Пожалуй
# хватит )
# 9
```
`break` отличная конструкция, которую нельзя не использовать в некоторых алгоритмах, но `break` не функциональный стиль программирования.

В ООП нет ничего, что предполагает `break` внутри метода - **ПЛОХАЯ** идея, так как может произойти путаница. На замену `break` отлично подходит `метод флажка`.

**ЗАДАЧА**: Пользователь вводит число, необходимо найти минимальный делитель данного числа
```Python
n = int(input("Введите число: "))
flag = True
i = 2
while flag:
    if n % i == 0: # если остаток при делении числа n на i равен 0
        flag = False
        print(i)
    elif i > n // 2: # делить числа не может превышать введенное число, деленное на 2
        print(n)
        flag = False
    i += 1
# алгоритм будет работать до тех пор, пока не найдется минимальный делитель введенного числа. Когда будет найден первый делитель цикл остановит свою работу, так как условие, которое находится внутри станет ложным(False)
```
#### [Цикл for](#цикл-for)
##### [Оглавление № 1](#лекция-№1)
В Python цикл `for` в основном используется для перебора значений
```Python
for i in enumeration:
    # operator 1
    # operator 2
    # ...
    # operator n
```
```Python
for i in 1, -2, 3, 14, 5:
    print(i)
# 1
# -2
# 3
# 14
# 5
```
#### [Цикл range](#цикл-range)
##### [Оглавление № 1](#лекция-№1)
* `Range` выдает значения из диапазона с шагом 1.
* Если указано только одно число — от 0 до заданного числа.
* Если нужен другой шаг, третьим аргументов можно задать приращение.
```Python
range(StartValue, EndValue, Step) # EndValue значение не включительно
range(StartValue, EndValue)       # EndValue значение не включительно
range(EndValue)                   # EndValue значение не включительно
```
```Python
r = range(5)            # 0 1 2 3 4
r = range(2, 5)         # 2 3 4
r = range(-5, 0)        # ----
r = range(1, 10, 2)     # 1 3 5 7
r = range(100, 0, -20)  # 100 80 60 40 20
r = range(100, 0, -20)  # range(100, 0, -20)
for i in r:
    print(i)            # 100 80 60 40 20
```
Можно использовать цикл `for` и со **строками**, так как у строк есть нумерация, такая же как и у массивов, начинается с 0:
```Python
for i in 'qwerty':
    print(i)
# q
# w
# e
# r
# t
# y
```
вложенные циклы:
```Python
line = ""
for i in range(5):
    line = ""
    for j in range(5):
        line += "*"
    print(line)
# *****
# *****
# *****
# *****
# *****

# Программный код выведет 5 строк "*****". Сначала запускается внешний цикл с i(счетчик цикла). После этого запускается внутренний цикл с j(счетчик цикла). После того как внутренний цикл завершил свою работу, переменная line = "*****" и выводится на экран, далее опять повторяется внешний цикл и так 5 раз.
```
#### [Команды для работы со строками](#команды-для-работы-со-строками)
##### [Оглавление № 1](#лекция-№1)
Возникают ситуации, когда в некоторых задачах необходимо поработать со строкой, которую ввел пользователь. Например: необходимо сделать все буквы маленькими, или поменять все буквы "ё" на "е".

```Python
text = 'СъЕШЬ ещё этих МяГкИх французских булок'
print(len(text))     # 39 Определить количество символов в строке
print('ещё' in text) # True Проверить наличие символа в строке (in)
print(text.lower())  # съешь ещё этих мягких французских булок
print(text.upper())  # СЪЕШЬ ЕЩЁ ЭТИХ МЯГКИХ ФРАНЦУЗСКИХ БУЛОК
print(text.replace('ещё','ЕЩЁ')) # СъЕШЬ ЕЩЁ этих МяГкИх французских булок
```
#### [Срезы](#срезы) 
```Python
text = 'съешь ещё этих мягких французских булок'
text[startIndex, endIndex, step]
text[startIndex, endIndex]
text[index]
```
Строка представляется в виде массива символов. Значит мы можем обращаться к элементам по индексам.

Отрицательное число в индексе — счёт идет с конца строки.
```Python
text = 'съешь ещё этих мягких французских булок'
print(text[0])              # c
print(text[1])              # ъ
print(text[len(text)-1])    # к
print(text[-5])             # б
print(text[:])              # съешь ещё этих мягких французских булок
print(text[:2])             # съ
print(text[len(text)-2:])   # ок
print(text[2:9])            # ешь ещё
print(text[6:-18])          # ещё этих мягких
print(text[0:len(text):6])  # сеикакл
print(text[::6])            # сеикакл
text = text[2:9] + text[-5] + text[:2]
print(text)                 # ешь ещёбсъ
```
___
<kbd> `Ctrl` </kbd> + <kbd> `F5` </kbd>  запуск через отладчик

___
##### [Оглавление № 1](#лекция-№1)